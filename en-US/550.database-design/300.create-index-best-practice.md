# Best practices for creating indexes on large tables

Global index and local index are two common index types in databases. A global index is built based on the data of an entire table and affects the overall query performance of the table. A local index is built based on the data of one or more partitions in a table and affects the query performance of only these partitions. A large amount of disk, CPU, and memory resources are required for creating an index. A global index processes the data of an entire table whereas a local index processes the data of one or more partitions. In practice, you can create indexes to significantly improve the efficiency of complex queries, especially when you need to frequently query data from a large table. You can also create indexes during data analysis to accelerate data aggregation and analysis.

In the distributed architecture of OceanBase Database, multiple OBServer nodes work together to complete index building. The system flexibly allocates resources based on the data partitions and the load for better resource utilization, and allows you to create global and local indexes as needed.

## Create indexes on large tables in OceanBase Database V4.x

In OceanBase Database V4.x, creating indexes on large tables consumes extensive system resources, leading to insufficient disk space and CPU resources. Index creation may also be affected by some limitations or known issues of OceanBase Database. Therefore, you need to properly plan resources to ensure smooth operation during index creation.

This section describes the considerations for creating indexes on large tables based on practical experience.

### Considerations

When you create indexes on large tables, take note of the following considerations to optimize resource utilization and avoid potential issues.

#### Disk space

In OceanBase Database V4.2.2 and later, local indexes can be built based on partition scheduling, which means that the maximum temporary space required for index creation is subject to the amount of data in the largest partition.

In OceanBase Database V4.2.3 and later, if the degree of parallelism (DOP) for index creation is equal to or higher than 8, the system compresses the temporary files generated during index creation by default, to reduce the disk space occupied. If the DOP is lower than 8 and the disk space is insufficient, you can modify the `_ob_ddl_temp_file_compress_func` parameter to enable compression for temporary files generated during index creation.

Extra CPU resources are consumed during the compression. Therefore, you need to determine whether to enable compression based on the amount of available CPU and disk resources.

```sql
# Enable compression and use the specified compression algorithm to compress temporary files generated during index creation.
alter system set _ob_ddl_temp_file_compress_func = 'ZSTD';
alter system set _ob_ddl_temp_file_compress_func = 'LZ4';
# Disable compression.
alter system set _ob_ddl_temp_file_compress_func = 'NONE’
# Determine whether to enable compression based on the DOP. If the DOP is equal to or higher than 8, compression is enabled and the compression algorithm of the primary table is used.
alter system set _ob_ddl_temp_file_compress_func = 'AUTO’
```

If you are using OceanBase Database V4.2.1 or earlier, see the **Estimate the temporary space required for index creation** section. If you are using OceanBase Database V4.2.2 or later, see the **Estimate the temporary space required for local index creation** section.

##### Estimate the temporary space required for index creation

Space amplification arises during index creation. Given the worst situation, the required temporary space is five times the original amount of data in the index table. The most complex part is to estimate the original data amount of the index table.

You can estimate the original amount of data in an index table based on the existing statistics of the primary table or an internal table.

**Method 1: Estimate based on statistics**

The procedure for estimating the required space based on [statistics](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001379970) is as follows:

1. The table-level statistics contain the number of data rows (`row_count`) in the primary table and the average row length (`avg_row_length`). You can calculate the amount of data in the primary table as follows: `data_size = row_count x avg_row_length`.
2. The column-level statistics contain the average column length (`avg_column_length`). You can calculate the amount of data in the index columns as follows: `index_size = data_size x (avg_column_length/avg_row_length)`.

The SQL syntaxes are as follows:

```sql
-- Retrieve table-level statistics
SELECT NUM_ROWS, AVG_ROW_LEN FROM ALL_TAB_STATISTICS WHERE OWNER = 'xxx' AND TABLE_NAME = 'xxx' AND OBJECT_TYPE = 'TABLE';

-- Retrieve column-level statistics
SELECT TABLE_NAME, COLUMN_NAME, AVG_COL_LEN FROM ALL_TAB_COL_STATISTICS WHERE TABLE_NAME = 'xxx' AND OWNER = 'xxx';
```

**Method 2: Estimate based on an internal table**

You can calculate the original amount of data in the primary table based on an internal table. The SQL syntax is as follows:

```sql
SELECT SUM(original_size) FROM __all_virtual_tablet_sstable_macro_info WHERE tablet_id IN (SELECT tablet_id FROM __all_virtual_tablet_to_table_history WHERE table_id = xxx);
```

Divide the original amount of data in the primary table by the number of replicas to obtain the amount of uncompressed data of the table. Then, estimate the amount of uncompressed column data in the index table based on the amount of uncompressed data in the primary table and the percentage of data in each column of the index table to data in the corresponding column of the primary table.

##### Estimate the temporary space required for local index table creation

The temporary space required for creating a local index table is subject to the total amount of data in the index partitions. Generally, all index building threads of a single partition are fully occupied. Therefore, you only need to consider the size of disk space occupied by the largest partition. For a single partition, you can use the methods described in the **Estimate the temporary space required for index creation** section for calculation, but you need to use the data amount of the largest partition.

<main id="notice" type='explain'>
  <h4>Notice</h4>
  <p>
    After you calculate the temporary space required, you also need to consider the 10% space to be reserved for other tasks by default on each OBServer node.
  </p>
</main>

#### Disable major compactions

To avoid space amplification of the primary table caused by the retention of snapshot points, we recommend that you perform the following steps to disable major compactions:

1. Set the `minor_freeze_times` parameter to a large value, such as `500`.
2. Set the `major_freeze_duty_time` parameter to `disable`.

#### CPU

If N CPU cores in the current cluster can be allocated for index creation, you can set the DOP of index creation to N.

In OceanBase Database V4.0 and later, DDL operations are executed in series by default. You can specify the DOP by using a session-level parameter. The rules for determining the DOP are as follows:

1. The total DOP of all DDL operations does not exceed the value of the `max_cpu` parameter of the tenant.
2. In OceanBase Database V4.0 and V4.1, the space occupied by temporary files is limited. We recommend that the total DOP of all DDL operations do not exceed 64. For more information, see the index building performance test.

You can set the DOP as follows:

1. MySQL mode: `SET SESSION _FORCE_PARALLEL_DDL_DOP = 8;`
2. Oracle mode: `ALTER SESSION FORCE PARALLEL DDL PARALLEL 8;`
3. In OceanBase Database V4.3.0 and later, you can use a hint to specify the DOP of DDL operations. The syntax is as follows: `ALTER /*+ PARALLEL(2) */ TABLE XXX;`.

After the DOP is adjusted, you also need to modify the value of the `parallel_servers_target` parameter.

```sql
SET GLOBAL parallel_servers_target = 100; -- Set this parameter to a value greater than the total DOP.
```

#### I/O

Generally, I/O isolation is not required if no I/O bottleneck exists.

You can enable I/O isolation to limit the I/O traffic of DDL operations such as index creation, to avoid affecting foreground business traffic during the DDL operations.

A DDL task can perform data completion through direct acyclic graph (DAG) tasks such as column deletion, or internal SQL statements such as `CREATE INDEX`. If data completion is performed through a DAG task, throttling can be implemented based on the function-level isolation relationship, namely, the DDL group bound to the function. If data completion is performed through an internal SQL statement, resource isolation is implemented based on the resource consumer group to which the user is bound, because this internal SQL statement is still executed by a parallel eXecution (PX) thread.

The following sample code creates a resource consumer group named `DDL_GROUP`, maps the current user `root` to the group, and specifies the resources available for the group to limit the usage of resources by the index creation task.

```sql
/* Create a resource management plan */
CALL DBMS_RESOURCE_MANAGER.CREATE_PLAN('DDL_PLAN','plan for ddl');
/* Create a resource consumer group */
CALL DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP => 'DDL_GROUP', COMMENT => 'DDL');
/* Create a plan directive */
CALL DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN => 'DDL_PLAN', GROUP_OR_SUBPLAN => 'DDL_GROUP', COMMENT => 'DDL', MAX_IOPS => 60);
/* Create mapping */
CALL DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING('USER', 'root', 'DDL_GROUP');
CALL DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING('FUNCTION', 'DDL', 'DDL_GROUP');
/* Enable the resource management plan */
SET GLOBAL resource_manager_plan = 'DDL_PLAN';
```

In the preceding example, the `root` user and the `DDL` function for executing the DDL task are mapped to the `DDL_GROUP` resource consumer group, and `max_iops=60` is configured to specify the resources available for the group. The maximum IOPS resources available for the DDL task is 60% of the current unit. You can view the isolation effect based on the I/O diagnostics table.

#### Memory

The modules with high memory usage during index creation are as follows:

1. Metadata memory of temporary files
2. Range information of the channel during execution
3. Buffer of the data transmission layer

For OceanBase Database V4.2.1 and earlier, it is known that the preceding modules occupy many memory resources. For OceanBase Database of a version later than V4.2.1, we recommend that you also check the memory usage of the preceding modules for higher performance.

##### Estimate the metadata memory required for temporary files

3.75 MB of metadata memory is required for 1 GB of temporary files. In OceanBase Database V4.2.1, a maximum of 70% of the tenant memory is available for the metadata memory module. When the metadata memory module has insufficient space, we recommend that you scale out the tenant memory.

##### Calculate the memory required for the range information of the channel

In OceanBase Database V4.2.1 and earlier, the memory required for the range information of the channel is calculated as follows:

+ DOP x DOP x Number of partitions x 1.5 KB

In OceanBase Database of a version later than V4.2.1, the memory required for the range information of the channel is calculated as follows:

+ DOP x Number of partitions x 1.5 KB

##### Calculate the size of memory for the buffer of the data transmission layer

The calculation formula is as follows: DOP x DOP x 64 KB x 3

### Procedure

To ensure successful index creation on a large table, perform the following steps:

1. **Evaluate the existing statistics of the table**: Run an SQL query to obtain the number of rows and average row length of the table. This is to ensure that the latest statistics are obtained.

   ```sql
   -- Retrieve table-level statistics
   SELECT NUM_ROWS, AVG_ROW_LEN
   FROM ALL_TAB_STATISTICS
   WHERE OWNER = 'xxx' AND TABLE_NAME = 'xxx' AND OBJECT_TYPE = 'TABLE';
   ```

2. **Estimate the temporary space required**: Estimate the space required for index creation based on statistics or an internal table. This is to ensure that sufficient temporary space is reserved.

   - Formula: `index_size = data_size x (avg_column_length/avg_row_length)`

   ```sql
   -- Retrieve column-level statistics
   SELECT TABLE_NAME, COLUMN_NAME, AVG_COL_LEN
   FROM ALL_TAB_COL_STATISTICS
   WHERE TABLE_NAME = 'xxx' AND OWNER = 'xxx';
   ```

   - **Estimate based on an internal table**

   ```sql
   SELECT SUM(original_size)
   FROM __all_virtual_tablet_sstable_macro_info
   WHERE tablet_id IN (SELECT tablet_id FROM __all_virtual_tablet_to_table_history WHERE table_id = xxx);
   ```

3. **Plan resources**: Adjust the memory settings of the OBServer node based on the estimated space and memory required.

   This is to ensure that the CPU and I/O resources can meet the DOP requirements.

   Calculate the memory required:

     - **Metadata memory of temporary files**: `Temporary space (GB) x 3.75 MB`
     - **Memory for the range information of the channel**: `DOP x Number of partitions x 1.5 KB`
     - **Memory for the buffer of the data transmission layer**: `DOP x DOP x 64 KB x 3`

   Compression settings for temporary files: In OceanBase Database V4.2.3 and later, if the DOP for index creation is equal to or higher than 8, the system compresses the temporary files generated during index creation by default.
   If the DOP is lower than 8 and the disk space is insufficient, you can enable compression to reduce the disk space occupied.
  
    ```sql
    -- Enable compression and use the specified compression algorithm.
    ALTER SYSTEM SET _ob_ddl_temp_file_compress_func = 'ZSTD'; -- or 'LZ4'

    -- Disable compression.
    ALTER SYSTEM SET _ob_ddl_temp_file_compress_func = 'NONE';

    -- Determine whether to enable compression based on the DOP. If the DOP is equal to or higher than 8, enable compression and use the compression algorithm of the primary table.
    ALTER SYSTEM SET _ob_ddl_temp_file_compress_func = 'AUTO';
    ```
    
4. **Configure parameters**: Set a DOP that does not exceed the CPU capacity of the tenant.

   ```sql
   -- MySQL mode
   SET SESSION _FORCE_PARALLEL_DDL_DOP = 8;

   -- Oracle mode
   ALTER SESSION FORCE PARALLEL DDL PARALLEL 8;

   -- Set a DOP for DDL operations in OceanBase Database V4.3.0 and later.
   ALTER /*+ PARALLEL(2) */ TABLE xxx;
   ```

5. **Disable major compactions**: Before index creation, adjust the major compaction parameters to avoid space amplification of the primary table caused by the retention of snapshot points.

   ```sql
   ALTER SYSTEM SET minor_freeze_times = 500;
   ALTER SYSTEM SET major_freeze_duty_time = 'disable';
   ```

### Verify the result

- Execute a query to verify whether the index has been created and whether the query performance has been significantly improved.
- Monitor the usage of resources to ensure that the disk, CPU, and memory resources are properly used without overloads.
- Check the logs to ensure that no error or warning is generated.

## Create indexes on large tables in OceanBase Database V3.x

In OceanBase Database V3.x, creating indexes on large tables consumes extensive system resources. This may lead to insufficient disk space and CPU resources. Index creation may also be affected by some limitations or known issues of OceanBase Database. Therefore, you need to make preparations to ensure smooth operation during index creation. This section describes the considerations for creating indexes on large tables based on practical experience.

### Considerations

When you create indexes on large tables, take note of the following considerations to optimize resource utilization and avoid potential issues.

#### Adjust the timeout period

It takes a very long time to create an index on a large table. Therefore, you need to adjust the timeout period to avoid index creation failure due to timeout.

Here is an example:

```sql
alter system set global_index_build_single_replica_timeout = '168h';
```

**Notice**: Set the timeout period based on your business scenario.

#### Configure the storage space

The storage space comprises two parts: disk and memory.

##### Configure the disk space

In OceanBase Database V3.x, a global index is created based on the data of an entire table, and a local index is created based on the data of multiple partitions. The temporary space required for creating a global index is subject to the amount of data in the entire table, and the temporary space required for creating a local index is subject to the total amount of data in the index partitions.

If you want to build a global or local index table, you need to reserve sufficient disk space.

###### Estimate the temporary space required for a global index table

The temporary space occupied by a global index table is subject to the amount of data in the entire table. You can estimate the required temporary space by using the following formulas:

1. Sum of the lengths of all index columns x Number of table rows x 5 Here is a sample statement for querying the average length of an index column:

   ```sql
   select sum(length(c1)) / count(1) from t1;
   ```

2. Total column length of the index table/Total column length of the primary table x Amount of compressed table data x Compression ratio (empirical value: 4)

   ```sql
   -- Query the amount of data in the primary table.
   select sum(data_size) from __all_virtual_meta_table where table_id = xxx and role = 1;
   ```

###### Estimate the temporary space required for a local index table

The temporary space occupied by a local index table is subject to the total amount of data in the index partitions. Generally, you only need to estimate the disk space occupied by the largest partition.

**Notice**

1. Reserve 10% of the total disk space on each OBServer node.
2. In a public cloud, we recommend that you ensure sufficient disk space. The disk space will be insufficient if the disk space is not scaled out in a timely manner. At present, the scaling step is 50 GB.

##### Configure the memory space

The memory space required for an index creation task is subject to the number of parallel threads running the task. The calculation method varies based on the index type.

You need to adjust the memory parameters to support data sorting. Here is an example:

```txt
ob_sql_work_area_percentage x Tenant memory size = Number of partitions in the primary table x Number of partitions in the index table x 16 MB
```

###### Estimate the memory space required for a global index

The memory space required for a global index creation task is subject to the number of partitions. You can calculate the required memory space by using the following formula:

```txt
Required memory space = Number of partitions in the primary table x Number of partitions in the index table x 8 MB
```

###### Estimate the memory space required for a local index

The formula for estimating the memory space required for a local index creation task is as follows:

```txt
Required memory space = Number of threads x 128 MB
```

The memory space occupied by local indexes is allocated from the sys500 tenant. You do not need to adjust related parameters.

#### Disable major compactions

You need to disable major compactions to avoid space amplification of tables caused by the retention of snapshot points. Configure the following parameters:

```shell
-- Set the `minor_freeze_times` parameter to a large value, such as `500`.
alter system set minor_freeze_times = 500;
-- Set the `major_freeze_duty_time` parameter to `disable`.
alter system set major_freeze_duty_time = disable;
```

#### Configure CPU resources

To avoid affecting business, you need to optimize the CPU utilization of the index creation task by using either of the following methods:

1. Reserve sufficient CPU resources for business. Here is an example:

   ```txt
   -- Reserve half of the remaining CPU resources for index creation.
   parallel_servers_target = (Number of physical CPU cores - Number of CPU cores required during peak business hours)/n
   ```

   **Notice**: Calculate the CPU resources based on your business scenario.

2. Transfer the index creation task on a follower to reduce the load on the leader. Here is an example:

   ```sql
   select svr_ip, count(1) from __all_virtual_sys_task_status where comment like 'build index task%' group by svr_ip;
   ```

   In the `__all_virtual_sys_task_status` table, `job=3` means that a task is in the sorting phase.

   Find the server where the index creation task (`task_type = 'create index'`) on the table is running and switch the business traffic from this server to another server.


**Notice**: The maximum DOP for global index creation tasks is 100.

#### Configure I/O resources

In OceanBase Database V3.x, the I/O resources for index creation are automatically adjusted based on the response time of user requests, and no special configuration is required.

### Procedure

You can perform the following steps:

1. **Adjust the timeout period**.

   ```shell
   alter system set global_index_build_single_replica_timeout = '168h';
   ```

2. **Adjust the disk space and reserved space**.

3. Disable major compactions.

   ```shell
   alter system set minor_freeze_times = 500;
   alter system set major_freeze_duty_time = disable;
   ```
4. **Optimize CPU configurations** to ensure sufficient CPU resources for business.

5. **Adjust memory parameters**.

   ```txt
   ob_sql_work_area_percentage x Tenant memory size = Number of partitions in the primary table x Number of partitions in the index table x 16 MB
   ```

6. **Start the index creation task**.

### Verify the result

1. Execute a query to verify whether the index has been created and whether the query performance has been significantly improved.
2. Monitor the usage of resources to ensure that the disk, CPU, and memory resources are properly used without overloads.
3. Check the logs to ensure that no error or warning is generated.

With the preceding measures, you can efficiently create indexes on large tables in OceanBase Database V3.x to improve the system performance and resource utilization.

## References

### OceanBase Database V4.x

Take OceanBase Database V4.3.3 as an example:

- [Create an index](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001717085) in Oracle mode
- [Overview](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001717083) in Oracle mode
- [Create an index](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001717102) in MySQL mode
- [Overview](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001717103) in MySQL mode

### OceanBase Database V3.x

OceanBase Database V3.2.x (Take OceanBase Database V3.2.1 as an example):

- [Create an index](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000368271) in Oracle mode
- [Overview](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000367516) in Oracle mode
- [Create an index](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000368235) in MySQL mode
- [Overview](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000366833) in MySQL mode


OceanBase Database V3.1.x (Take OceanBase Database V3.1.2 as an example):

- [Create an index](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000361487) in Oracle mode
- [Overview](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000360337) in Oracle mode
- [Create an index](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000361399) in MySQL mode
- [Overview](https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000359623) in MySQL mode
